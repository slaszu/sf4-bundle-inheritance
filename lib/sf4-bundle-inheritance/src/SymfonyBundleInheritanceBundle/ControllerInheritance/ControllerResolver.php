<?php

declare(strict_types=1);

namespace SymfonyBundleInheritanceBundle\ControllerInheritance;

use Symfony\Bundle\FrameworkBundle\Controller\ControllerNameParser;
use Symfony\Bundle\FrameworkBundle\Controller\ControllerResolver as BaseControllerResolver;
use SymfonyBundleInheritanceBundle\Util\BundleHierarchyCollection;
use SymfonyBundleInheritanceBundle\Util\ParentChild\Collection;
use SymfonyBundleInheritanceBundle\Util\ParentChild\Item;

class ControllerResolver extends BaseControllerResolver
{
    protected Collection $parentChildCollection;

    public function setParser(ControllerNameParser $parser): void
    {
        $this->parser = $parser;
    }

    public function initInheritance(Collection $parentChildCollection): void
    {
        dump($parentChildCollection);
        $this->parentChildCollection = $parentChildCollection;
    }

    protected function modifyControllerIfNeeded(string $controller): string
    {
        $parentChildItems = $this->parentChildCollection->getItems();
        foreach ($parentChildItems as $parentChildItem) {
            if (strpos($controller, $parentChildItem->getParent()->getNamespace()) !== false) {
                return $this->getChildControllerIfExists($controller, $parentChildItem);
            }
        }

        return $controller;
    }

    protected function getChildControllerIfExists(
        string $controller,
        Item $parentChildItem
    ): string {

        // method remove
        $parts = explode('::', $controller);
        if (count($parts) != 2) {
            // we dont know how to process this format
            return $controller;
        }

        [$controllerName, $methodName] = $parts;

        // remove parent namespace
        // add child namespace

        $controllerChild = str_replace(
            $parentChildItem->getParent()->getNamespace(),
            $parentChildItem->getChild()->getNamespace(),
            $controllerName
        );

        // check if file exists
        if (class_exists($controllerChild)) {
            return $controllerChild.'::'.$methodName;
        }

        return $controller;
    }


    protected function createController($controller)
    {
        // FQCN : AcmeBundle\Controller\LoginController::userAction (new way)

        // a:b:c  AcmeBundle:Login:user (supported by parser '@.legacy_controller_name_converter' )

        // other:
        // - id of services from container ?

        // @todo how services_controllers it works in sf3.4
        // in previus version of fosuserbundle routing was lik this
        /*
        <route id="fos_user_security_login" path="/login" methods="GET POST">
            <default key="_controller">FOSUserBundle:Security:login</default>
        </route>

        now it looks like

        <route id="fos_user_security_login" path="/login" methods="GET POST">
            <default key="_controller">fos_user.security.controller:loginAction</default>
        </route>
         */

        $controller = $this->modifyControllerIfNeeded($controller);

        $r = parent::createController($controller); // TODO: Change the autogenerated stub

        dump($controller);
        dump($r);
        exit;

        return $r;
    }

    protected function instantiateController($class)
    {
        dump($class);

        if ($this->container->has($class)) {
            dump($this->container->getServiceIds());
            $service = $this->container->get($class);

            /**
             * A.
             * 1. pobrac serwis
             * 2. pobrac klase serwisu
             * 3. sprawdzic czy bundle z którego pochodzi serwis jest nadpisany, jak tak to dalej
             * 4. sprawdzic czy istnieje controller NEW w nadpisaniu (według lokalizacji klasy z pkt 2) jak tak to dalje
             * 5. opcje dla NEW:
             *  a) moze mieć definicje w di, (JAK TO SPRAWDZIC ?)
             * - pobrac przeystkie serwisy
             *  b) moze NIE miec definicji, wtedy ja trzeba utworzyc
             *
             * B. command
             * - wygeneruje serwisy z docoratorami dla nadpisanych controllerow
             * 1) pobrać wszytkie routy z controllerami
             * 2) dla kazdego controllera sprawdzic czy nalezy do nadpisanego bundla jak tak to dalej
             * 3) .... powtorz akcje z A.4-..... !!!!!!
             */

            dump($this->parentChildCollection);
            dump(get_class($service));
            dump('exit');
            exit;
        }

        return parent::instantiateController($class); // TODO: Change the autogenerated stub
    }
}